"use strict";var _events=_interopRequireDefault(require("events"));Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function ownKeys(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d)}return c}function _objectSpread(a){for(var b,c=1;c<arguments.length;c++)b=null==arguments[c]?{}:arguments[c],c%2?ownKeys(Object(b),!0).forEach(function(c){_defineProperty(a,c,b[c])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(b)):ownKeys(Object(b)).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))});return a}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}const State={IDLE:0,RUNNING:1,STOPPED:2};class Queue extends _events.default{constructor(a={}){super(),_defineProperty(this,"tasks",new Map),_defineProperty(this,"uniqueId",0),_defineProperty(this,"lastRan",0),_defineProperty(this,"currentlyHandled",0),_defineProperty(this,"state",State.IDLE),_defineProperty(this,"options",{concurrent:5,interval:500,start:!0}),this.options=_objectSpread(_objectSpread({},this.options),a),this.options.interval=parseInt(this.options.interval,10),this.options.concurrent=parseInt(this.options.concurrent,10)}start(){this.state===State.RUNNING||this.isEmpty||(this.state=State.RUNNING,this.emit("start"),(async()=>{for(;this.shouldRun;)await this.dequeue()})())}stop(){clearTimeout(this.timeoutId),this.state=State.STOPPED,this.emit("stop")}finalize(){this.currentlyHandled-=1,0===this.currentlyHandled&&this.isEmpty&&(this.stop(),this.state=State.IDLE,this.emit("end"))}async execute(){const a=[];this.tasks.forEach((b,c)=>{this.currentlyHandled<this.options.concurrent&&(this.currentlyHandled++,this.tasks.delete(c),a.push(Promise.resolve(b()).then(a=>(this.emit("resolve",a),a)).catch(a=>(this.emit("reject",a),a)).finally(()=>{this.emit("dequeue"),this.finalize()})))});const b=await Promise.all(a);return 1===this.options.concurrent?b[0]:b}dequeue(){const{interval:a}=this.options;return new Promise(b=>{const c=Math.max(0,a-(Date.now()-this.lastRan));clearTimeout(this.timeoutId),this.timeoutId=setTimeout(()=>{this.lastRan=Date.now(),this.execute().then(b)},c)})}enqueue(a){if(Array.isArray(a))return void a.map(a=>this.enqueue(a));if("function"!=typeof a)throw new Error(`You must provide a function, not ${typeof a}.`);this.uniqueId=(this.uniqueId+1)%Number.MAX_SAFE_INTEGER,this.tasks.set(this.uniqueId,a),this.options.start&&this.state!==State.STOPPED&&this.start()}add(a){this.enqueue(a)}clear(){this.tasks.clear()}get size(){return this.tasks.size}get isEmpty(){return 0===this.size}get shouldRun(){return!this.isEmpty&&this.state!==State.STOPPED}}exports.default=Queue,module.exports=exports.default;