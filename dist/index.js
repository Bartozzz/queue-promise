"use strict";var _events=_interopRequireDefault(require("events"));Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function ownKeys(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d)}return c}function _objectSpread(a){for(var b,c=1;c<arguments.length;c++)b=null==arguments[c]?{}:arguments[c],c%2?ownKeys(Object(b),!0).forEach(function(c){_defineProperty(a,c,b[c])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(b)):ownKeys(Object(b)).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))});return a}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}class Queue extends _events.default{constructor(a={}){super(),_defineProperty(this,"tasks",new Map),_defineProperty(this,"uniqueId",0),_defineProperty(this,"lastRan",void 0),_defineProperty(this,"timeoutId",void 0),_defineProperty(this,"currentlyHandled",0),_defineProperty(this,"options",{concurrent:5,interval:500,start:!0}),_defineProperty(this,"started",!1),_defineProperty(this,"stopped",!1),this.options=_objectSpread({},this.options,{},a),this.options.interval=parseInt(this.options.interval,10),this.options.concurrent=parseInt(this.options.concurrent,10),a.concurrency&&(this.options.concurrent=parseInt(a.concurrency,10))}start(){this.started||this.isEmpty||(this.stopped=!1,this.started=!0,this.emit("start"),(async()=>{for(;!this.isEmpty&&!this.stopped;)await this.dequeue()})())}stop(){this.stopped=!0,this.started=!1,clearTimeout(this.timeoutId),this.emit("stop")}finalize(){this.currentlyHandled-=1,0===this.currentlyHandled&&this.isEmpty&&(this.emit("end"),this.stop(),this.stopped=!1)}async execute(){const a=[];this.tasks.forEach((b,c)=>{this.currentlyHandled<this.options.concurrent&&(this.currentlyHandled++,this.tasks.delete(c),a.push(Promise.resolve(b()).then(a=>(this.emit("resolve",a),a)).catch(a=>(this.emit("reject",a),a)).finally(()=>{this.emit("dequeue"),this.finalize()})))});const b=await Promise.all(a);return 1===this.options.concurrent?b[0]:b}dequeue(){const{interval:a}=this.options;return new Promise(b=>{this.lastRan||(this.lastRan=-Date.now()+a),clearTimeout(this.timeoutId),this.timeoutId=setTimeout(()=>{this.lastRan=Date.now(),this.execute().then(b)},a-(Date.now()-this.lastRan))})}enqueue(a){if(Array.isArray(a))return void a.map(a=>this.enqueue(a));if("function"!=typeof a)throw new Error(`You must provide a function, not ${typeof a}.`);this.tasks.set(this.uniqueId++,a),this.options.start&&!this.stopped&&this.start()}add(a){this.enqueue(a)}clear(){this.tasks.clear()}get isEmpty(){return 0===this.tasks.size}}exports.default=Queue,module.exports=exports.default;